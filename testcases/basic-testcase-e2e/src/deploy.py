#!/usr/bin/env python3
"""
E2E Test Script for UiPath Coded Agents

This script:
1. Creates a temporary folder in Orchestrator
2. Uploads the packed NuGet package
3. Creates a process
4. Runs a job and polls for completion
5. Fetches and saves the job output
6. Cleans up (deletes the folder)

Uses tokens from .env generated by `uipath auth`
"""

import glob
import json
import os
import sys
import time
from datetime import datetime
from typing import Any, Optional
from urllib.parse import urlparse

import httpx
from dotenv import load_dotenv


class OrchestratorClient:
    """Client for interacting with the UiPath Orchestrator API."""

    def __init__(
        self,
        access_token: str,
        uipath_url: str,
    ):
        """
        Initialize client using tokens from uipath auth.

        Args:
            access_token: Bearer token from UIPATH_ACCESS_TOKEN
            uipath_url: Full URL like https://alpha.uipath.com/AccountName/TenantName
        """
        # Parse the URL to extract base_url, account, and tenant
        parsed = urlparse(uipath_url)
        path_parts = parsed.path.strip("/").split("/")

        if len(path_parts) >= 2:
            self._account_name = path_parts[0]
            self._tenant_name = path_parts[1]
        else:
            raise ValueError(f"Invalid UIPATH_URL format: {uipath_url}")

        self.base_url = f"{parsed.scheme}://{parsed.netloc}"
        self._folder_id: Optional[str] = None

        self.client = httpx.Client(timeout=120)
        self.client.headers.update({"Authorization": f"Bearer {access_token}"})

        print(f"Using account: {self._account_name}, tenant: {self._tenant_name}")

    @property
    def orchestrator_url(self) -> str:
        """Get the Orchestrator OData URL."""
        return f"{self.base_url}/{self._account_name}/{self._tenant_name}/orchestrator_/odata"

    def set_folder(self, folder_id: int):
        """Set the folder context for subsequent requests."""
        self._folder_id = str(folder_id)
        self.client.headers.update({"X-UIPATH-OrganizationUnitId": self._folder_id})

    def create_folder(self, folder_name: str, parent_folder_id: Optional[int] = None) -> int:
        """Create a new folder and return its ID."""
        print(f"Creating folder '{folder_name}'...")
        payload: dict[str, Any] = {
            "DisplayName": folder_name,
            "ProvisionType": "Manual",
            "PermissionModel": "InheritFromTenant",
        }
        if parent_folder_id:
            payload["ParentId"] = parent_folder_id

        response = self.client.post(f"{self.orchestrator_url}/Folders", json=payload)
        response.raise_for_status()
        folder_id = response.json()["Id"]
        print(f"Folder created with ID: {folder_id}")
        return folder_id

    def delete_folder(self, folder_id: int):
        """Delete a folder by ID."""
        print(f"Deleting folder {folder_id}...")
        response = self.client.delete(f"{self.orchestrator_url}/Folders({folder_id})")
        response.raise_for_status()
        print("Folder deleted successfully.")

    def get_folder_by_name(self, folder_name: str) -> Optional[int]:
        """Get folder ID by name, returns None if not found."""
        params = {"$filter": f"DisplayName eq '{folder_name}'"}
        response = self.client.get(f"{self.orchestrator_url}/Folders", params=params)
        response.raise_for_status()
        folders = response.json().get("value", [])
        if folders:
            return folders[0]["Id"]
        return None

    def upload_package(self, package_path: str):
        """Upload a NuGet package to Orchestrator."""
        print(f"Uploading package '{package_path}'...")
        with open(package_path, "rb") as f:
            files = {"file": (os.path.basename(package_path), f, "application/octet-stream")}
            response = self.client.post(
                f"{self.orchestrator_url}/Packages/UiPath.Server.Configuration.OData.UploadPackage",
                files=files,
            )
            response.raise_for_status()
        print("Package uploaded successfully.")
        # Wait for package to be processed
        time.sleep(3)

    def get_package_version(self, package_name: str) -> str:
        """Get the latest version of a package."""
        params = {"$filter": f"Id eq '{package_name}'", "$orderby": "Version desc", "$top": 1}
        response = self.client.get(f"{self.orchestrator_url}/Packages", params=params)
        response.raise_for_status()
        packages = response.json().get("value", [])
        if not packages:
            raise FileNotFoundError(f"Package '{package_name}' not found")
        return packages[0]["Version"]

    def create_process(
        self, name: str, package_name: str, package_version: str, entry_point: str = "main.py"
    ) -> str:
        """Create a new process and return its key."""
        print(f"Creating process '{name}'...")
        payload = {
            "Name": name,
            "PackageIdentifier": package_name,
            "PackageVersion": package_version,
            "EntryPointPath": entry_point,
            "Description": "E2E test process",
        }
        response = self.client.post(f"{self.orchestrator_url}/Processes", json=payload)
        response.raise_for_status()
        process_key = response.json()["Key"]
        print(f"Process created with key: {process_key}")
        return process_key

    def start_job(self, process_name: str, input_args: Optional[dict] = None) -> int:
        """Start a job and return its ID."""
        print(f"Starting job for process '{process_name}'...")
        payload = {
            "startInfo": {
                "ReleaseKey": process_name,
                "JobsCount": 1,
                "Source": "Manual",
                "InputArguments": json.dumps(input_args) if input_args else "{}",
            }
        }
        response = self.client.post(
            f"{self.orchestrator_url}/Jobs/UiPath.Server.Configuration.OData.StartJobs",
            json=payload,
        )
        response.raise_for_status()
        jobs = response.json().get("value", [])
        if not jobs:
            raise RuntimeError("Failed to start job: No job data returned")
        job_id = jobs[0]["Id"]
        print(f"Job started with ID: {job_id}")
        return job_id

    def get_job(self, job_id: int) -> dict:
        """Get job details by ID."""
        response = self.client.get(f"{self.orchestrator_url}/Jobs({job_id})")
        response.raise_for_status()
        return response.json()

    def wait_for_job(self, job_id: int, timeout: int = 300, poll_interval: int = 5) -> dict:
        """Poll until job completes or times out."""
        print(f"Waiting for job {job_id} to complete (timeout: {timeout}s)...")
        start_time = time.time()
        terminal_states = {"Successful", "Faulted", "Stopped", "Terminated", "Suspended"}

        while time.time() - start_time < timeout:
            job = self.get_job(job_id)
            state = job.get("State")
            print(f"  Job state: {state}")

            if state in terminal_states:
                return job

            time.sleep(poll_interval)

        raise TimeoutError(f"Job {job_id} did not complete within {timeout} seconds")

    def close(self):
        """Close the HTTP client."""
        self.client.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


def find_package_file() -> str:
    """Find the .nupkg file in .uipath directory."""
    package_files = glob.glob(".uipath/*.nupkg")
    if not package_files:
        raise FileNotFoundError("No .nupkg file found in .uipath directory. Run 'uipath pack' first.")
    return package_files[0]


def save_job_output(job: dict, output_dir: str = "__uipath"):
    """Save job output to a JSON file."""
    os.makedirs(output_dir, exist_ok=True)
    output_file = os.path.join(output_dir, "output.json")

    # Parse OutputArguments if it's a string
    output_args = job.get("OutputArguments", "{}")
    if isinstance(output_args, str):
        try:
            output_args = json.loads(output_args)
        except json.JSONDecodeError:
            output_args = {}

    output_data = {
        "status": "successful" if job.get("State") == "Successful" else "failed",
        "job_id": job.get("Id"),
        "job_key": job.get("Key"),
        "state": job.get("State"),
        "info": job.get("Info"),
        "output": output_args,
    }

    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(output_data, f, indent=2)

    print(f"Job output saved to {output_file}")


def main():
    # Load environment variables from .env (generated by uipath auth)
    load_dotenv()

    access_token = os.environ.get("UIPATH_ACCESS_TOKEN")
    uipath_url = os.environ.get("UIPATH_URL")

    if not access_token or not uipath_url:
        print("Error: UIPATH_ACCESS_TOKEN and UIPATH_URL must be set")
        print("Run 'uipath auth' first to generate these values")
        sys.exit(1)

    # Generate unique folder name
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_id = os.environ.get("GITHUB_RUN_ID", timestamp)
    folder_name = f"UIPATH_CODED_AGENTS_TESTING_AREA_E2E_{run_id}"

    # Package info
    package_name = "python-script-basic-e2e"
    input_args = {"message": "Hello from E2E test", "repeat": 3, "prefix": "E2E"}

    folder_id = None
    success = False

    try:
        package_path = find_package_file()
        print(f"Found package: {package_path}")

        with OrchestratorClient(access_token, uipath_url) as client:
            # 1. Create folder
            folder_id = client.create_folder(folder_name)
            client.set_folder(folder_id)

            # 2. Upload package
            client.upload_package(package_path)

            # 3. Get package version and create process
            version = client.get_package_version(package_name)
            process_key = client.create_process(package_name, package_name, version)

            # 4. Start job
            job_id = client.start_job(process_key, input_args)

            # 5. Wait for completion
            job = client.wait_for_job(job_id, timeout=300)

            # 6. Save output
            save_job_output(job)

            success = job.get("State") == "Successful"
            if success:
                print("\n✓ E2E test completed successfully!")
            else:
                print(f"\n✗ Job ended with state: {job.get('State')}")
                print(f"  Info: {job.get('Info')}")

    except Exception as e:
        print(f"\n✗ Error: {e}")
        # Still try to save error output
        os.makedirs("__uipath", exist_ok=True)
        with open("__uipath/output.json", "w") as f:
            json.dump({"status": "failed", "error": str(e)}, f, indent=2)

    finally:
        # 7. Cleanup - delete folder
        if folder_id:
            try:
                with OrchestratorClient(access_token, uipath_url) as client:
                    client.delete_folder(folder_id)
            except Exception as cleanup_error:
                print(f"Warning: Failed to delete folder: {cleanup_error}")

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

# Phase 1: SpanProcessor Integration

**Timeline:** Week 1, Days 4-5
**Goal:** Wrap prototype logic in OpenTelemetry SpanProcessor interface

## Overview

Takes validated transformation logic from Phase 0 and integrates into OpenTelemetry's SpanProcessor interface. Allows processor to intercept spans as generated by LangGraph and transform before export.

## Prerequisites

- ✅ Phase 0 completed
- ✅ `span_transformer.py` logic validated
- ✅ Test fixtures and expected outputs defined

## Tasks

### 1. Create LangGraphCollapsingSpanProcessor

**Create:** `src/uipath/tracing/_langgraph_processor.py`

**Implementation:**
```python
from opentelemetry.sdk.trace import ReadableSpan, SpanProcessor, StatusCode
from typing import Dict, Optional, List
import uuid
from datetime import datetime

class AgentExecution:
    """Tracks lifecycle of single LangGraph agent execution."""

    def __init__(self, trace_id: str, parent_span: ReadableSpan):
        self.trace_id = trace_id
        self.parent_span = parent_span
        self.start_time = parent_span.start_time
        self.end_time: Optional[int] = None
        self.status = 0  # 0 = running
        self.buffered_spans: List[ReadableSpan] = []
        self.synthetic_span_id = str(uuid.uuid4())

    def add_buffered_span(self, span: ReadableSpan):
        """Buffer node span (agent/action) without exporting."""
        self.buffered_spans.append(span)

    def complete(self, end_time: int, status: int):
        """Mark execution as complete."""
        self.end_time = end_time
        self.status = status  # 1 = success, 2 = error


class LangGraphCollapsingSpanProcessor(SpanProcessor):
    """
    Simplifies LangGraph traces by:
    1. Collapsing node spans into single "Agent run - Agent" parent
    2. Emitting progressive state updates (running → completed)
    3. Passing through LLM/tool call spans unchanged
    """

    def __init__(self, next_processor: SpanProcessor):
        self.next_processor = next_processor
        self.active_executions: Dict[str, AgentExecution] = {}

    def on_start(self, span: ReadableSpan, parent_context=None):
        """Pass through to next processor."""
        self.next_processor.on_start(span, parent_context)

    def on_end(self, span: ReadableSpan):
        """Main processing logic."""
        span_name = span.name
        trace_id = format(span.get_span_context().trace_id, '032x')

        # 1. LangGraph parent span
        if span_name == "LangGraph":
            self._handle_langgraph_parent(span, trace_id)
            return

        # 2. Node span (agent/action)
        if self._is_node_span(span):
            self._handle_node_span(span, trace_id)
            return

        # 3. LLM/tool span - pass through
        self._export_span(span)

    def _handle_langgraph_parent(self, span: ReadableSpan, trace_id: str):
        """Handle main LangGraph span."""
        execution = AgentExecution(trace_id, span)
        self.active_executions[trace_id] = execution

        # Emit synthetic "Agent run - Agent" span with Status=0 (running)
        self._emit_synthetic_span(execution, is_final=False)

        # Check if execution ended
        if span.end_time:
            status = 1 if span.status.status_code == StatusCode.OK else 2
            execution.complete(span.end_time, status)

            # Emit final update with Status=1 (completed)
            self._emit_synthetic_span(execution, is_final=True)

            # Cleanup
            del self.active_executions[trace_id]

    def _is_node_span(self, span: ReadableSpan) -> bool:
        """Check if LangGraph node span to buffer."""
        attrs = dict(span.attributes) if span.attributes else {}

        # LangGraph-specific attributes
        if "langgraph.node" in attrs:
            return True

        # Span name patterns
        if span.name in ["agent", "action"] or span.name.startswith("action:"):
            return True

        return False

    def _handle_node_span(self, span: ReadableSpan, trace_id: str):
        """Buffer node spans without exporting."""
        execution = self.active_executions.get(trace_id)
        if execution:
            execution.add_buffered_span(span)

    def _emit_synthetic_span(self, execution: AgentExecution, is_final: bool):
        """Create and export synthetic 'Agent run - Agent' span."""
        original_attrs = dict(execution.parent_span.attributes) if execution.parent_span.attributes else {}

        synthetic_attrs = original_attrs.copy()
        synthetic_attrs["openinference.span.kind"] = "CHAIN"
        synthetic_attrs["langgraph.simplified"] = True
        synthetic_attrs["langgraph.node_count"] = len(execution.buffered_spans)

        synthetic_span_dict = {
            "id": execution.synthetic_span_id,
            "trace_id": execution.trace_id,
            "name": "Agent run - Agent",
            "parent_id": None,
            "start_time": datetime.fromtimestamp(execution.start_time / 1e9).isoformat() + "Z",
            "end_time": (datetime.fromtimestamp(execution.end_time / 1e9).isoformat() + "Z") if is_final and execution.end_time else None,
            "status": execution.status,
            "attributes": synthetic_attrs,
            "span_type": "OpenTelemetry"
        }

        self._export_synthetic_span(synthetic_span_dict)

    def _export_span(self, span: ReadableSpan):
        """Export regular span via next processor."""
        self.next_processor.on_end(span)

    def _export_synthetic_span(self, span_dict: dict):
        """Export synthetic span."""
        self.next_processor.on_end(span_dict)

    def shutdown(self):
        """Shutdown processor."""
        self.active_executions.clear()
        self.next_processor.shutdown()

    def force_flush(self, timeout_millis: int = 30000) -> bool:
        """Force flush next processor."""
        return self.next_processor.force_flush(timeout_millis)
```

### 2. Unit Tests

**Create:** `tests/test_langgraph_processor.py`

```python
import pytest
from unittest.mock import Mock
from opentelemetry.sdk.trace import ReadableSpan, StatusCode
from opentelemetry.trace import SpanContext
from uipath.tracing._langgraph_processor import (
    LangGraphCollapsingSpanProcessor,
    AgentExecution
)

class TestLangGraphCollapsingSpanProcessor:

    def create_mock_span(self, name: str, trace_id: str, span_id: str,
                        parent_id: Optional[str] = None,
                        attributes: Optional[dict] = None,
                        start_time: int = 1000000000,
                        end_time: int = 2000000000) -> ReadableSpan:
        """Helper to create mock ReadableSpan objects."""
        span = Mock(spec=ReadableSpan)
        span.name = name
        span.start_time = start_time
        span.end_time = end_time
        span.attributes = attributes or {}

        span_context = Mock(spec=SpanContext)
        span_context.trace_id = int(trace_id, 16)
        span_context.span_id = int(span_id, 16)
        span.get_span_context.return_value = span_context

        span.status = Mock()
        span.status.status_code = StatusCode.OK

        return span

    def test_langgraph_parent_detection(self):
        """Test LangGraph parent spans correctly identified."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        langgraph_span = self.create_mock_span(
            name="LangGraph",
            trace_id="abc123",
            span_id="span001"
        )

        processor.on_end(langgraph_span)

        # Created active execution
        assert "abc123" in processor.active_executions

    def test_node_span_buffering(self):
        """Test agent/action spans buffered, not exported."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        langgraph_span = self.create_mock_span(
            name="LangGraph",
            trace_id="abc123",
            span_id="span001"
        )
        processor.on_end(langgraph_span)

        agent_span = self.create_mock_span(
            name="agent",
            trace_id="abc123",
            span_id="span002",
            attributes={"langgraph.node": "agent"}
        )
        processor.on_end(agent_span)

        execution = processor.active_executions.get("abc123")
        assert execution is not None
        assert len(execution.buffered_spans) == 1
        assert execution.buffered_spans[0].name == "agent"

    def test_llm_span_passthrough(self):
        """Test LLM spans passed through unchanged."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        llm_span = self.create_mock_span(
            name="gpt-4o",
            trace_id="abc123",
            span_id="span003",
            attributes={"openinference.span.kind": "LLM"}
        )

        processor.on_end(llm_span)

        next_processor.on_end.assert_called_with(llm_span)

    def test_tool_span_passthrough(self):
        """Test tool call spans passed through unchanged."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        tool_span = self.create_mock_span(
            name="search_people_email",
            trace_id="abc123",
            span_id="span004",
            attributes={"openinference.span.kind": "TOOL"}
        )

        processor.on_end(tool_span)

        next_processor.on_end.assert_called_with(tool_span)

    def test_synthetic_span_emission(self):
        """Test synthetic 'Agent run - Agent' span created."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        langgraph_span = self.create_mock_span(
            name="LangGraph",
            trace_id="abc123",
            span_id="span001",
            start_time=1000000000,
            end_time=2000000000
        )

        processor.on_end(langgraph_span)

        # Called at least twice (running + completed)
        assert next_processor.on_end.call_count >= 2

        calls = next_processor.on_end.call_args_list

        # First call: running state
        running_span = calls[0][0][0]
        if isinstance(running_span, dict):
            assert running_span["name"] == "Agent run - Agent"
            assert running_span["status"] == 0
            assert running_span["end_time"] is None

        # Last call: completed state
        completed_span = calls[-1][0][0]
        if isinstance(completed_span, dict):
            assert completed_span["name"] == "Agent run - Agent"
            assert completed_span["status"] == 1
            assert completed_span["end_time"] is not None

    def test_concurrent_executions(self):
        """Test multiple concurrent agent executions."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        span1 = self.create_mock_span("LangGraph", "trace001", "span001")
        span2 = self.create_mock_span("LangGraph", "trace002", "span002")

        processor.on_end(span1)
        processor.on_end(span2)

        # Track both
        assert "trace001" in processor.active_executions
        assert "trace002" in processor.active_executions

        node1 = self.create_mock_span("agent", "trace001", "span003",
                                     attributes={"langgraph.node": "agent"})
        node2 = self.create_mock_span("agent", "trace002", "span004",
                                     attributes={"langgraph.node": "agent"})

        processor.on_end(node1)
        processor.on_end(node2)

        # Each buffers own spans
        assert len(processor.active_executions["trace001"].buffered_spans) == 1
        assert len(processor.active_executions["trace002"].buffered_spans) == 1

    def test_cleanup_after_completion(self):
        """Test completed executions cleaned up."""
        next_processor = Mock()
        processor = LangGraphCollapsingSpanProcessor(next_processor)

        langgraph_span = self.create_mock_span(
            name="LangGraph",
            trace_id="abc123",
            span_id="span001",
            end_time=2000000000
        )

        processor.on_end(langgraph_span)

        # Cleaned up after completion
        assert "abc123" not in processor.active_executions
```

**Run tests:**
```bash
pytest tests/test_langgraph_processor.py -v --cov=uipath.tracing._langgraph_processor
```

**Target:** 90%+ coverage

## Success Criteria

- ✅ Correctly implements SpanProcessor interface
- ✅ Chains with BatchSpanProcessor
- ✅ Identifies LangGraph parent spans
- ✅ Buffers node spans
- ✅ Passes through LLM/tool spans
- ✅ Emits synthetic span with progressive states
- ✅ Handles concurrent executions
- ✅ 90%+ test coverage

## Deliverables

1. `src/uipath/tracing/_langgraph_processor.py`
2. `tests/test_langgraph_processor.py`
3. Test coverage report (90%+)

## Integration

**Usage:**
```python
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from uipath.tracing._langgraph_processor import LangGraphCollapsingSpanProcessor
from uipath.tracing._otel_exporters import LlmOpsHttpExporter

provider = TracerProvider()
exporter = LlmOpsHttpExporter(...)

langgraph_processor = LangGraphCollapsingSpanProcessor(
    next_processor=BatchSpanProcessor(exporter)
)

provider.add_span_processor(langgraph_processor)
```

**Pipeline:**
```
Span ends → LangGraphCollapsingSpanProcessor → BatchSpanProcessor → Exporter → API
```

## Timeline

- **Day 4 AM:** Create `_langgraph_processor.py`
- **Day 4 PM:** Port transformation logic from Phase 0
- **Day 5 AM:** Write unit tests
- **Day 5 PM:** Refine edge cases, achieve 90%+ coverage
